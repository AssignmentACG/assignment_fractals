// Generated by CoffeeScript 1.10.0
var HEIGHT, ITER, WIDTH, ambientLight, animate, base_geometry, camera, controls, cube, i, iter_geometry, j, k, l, len, len1, lights, make_fractal, material, ref, render, renderer, scene, transform_matrices, transform_vector, transform_vector_array, transform_vectors, transform_vectors_array;

WIDTH = window.innerWidth;

HEIGHT = window.innerHeight;

ITER = 3;

scene = new THREE.Scene();

camera = new THREE.PerspectiveCamera(25, WIDTH / HEIGHT, 1, 20);

camera.position.z = 5;

scene.add(camera);

ambientLight = new THREE.AmbientLight(0x000000);

scene.add(ambientLight);

lights = [];

lights[0] = new THREE.PointLight(0xffffff, 1, 0);

lights[1] = new THREE.PointLight(0xffffff, 1, 0);

lights[2] = new THREE.PointLight(0xffffff, 1, 0);

lights[0].position.set(0, 20, 0);

lights[1].position.set(10, 20, 10);

lights[2].position.set(-10, -20, -10);

scene.add(lights[0]);

scene.add(lights[1]);

scene.add(lights[2]);

renderer = new THREE.WebGLRenderer({
  antialias: true
});

renderer.setSize(WIDTH, HEIGHT);

document.body.appendChild(renderer.domElement);

render = function() {
  requestAnimationFrame(render);
  return renderer.render(scene, camera);
};

render();

controls = new THREE.TrackballControls(camera);

controls.rotateSpeed = 1.0;

controls.zoomSpeed = 1.2;

controls.panSpeed = 0.8;

controls.noZoom = false;

controls.noPan = false;

controls.staticMoving = true;

controls.dynamicDampingFactor = 0.3;

controls.keys = [65, 83, 68];

controls.addEventListener('change', render);

animate = function() {
  requestAnimationFrame(animate);
  return controls.update();
};

animate();

base_geometry = new THREE.BoxGeometry(1, 1, 1);

material = new THREE.MeshStandardMaterial({
  color: '#2194ce'
});

transform_vectors_array = [[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1], [1, 1, 0], [1, -1, 0], [-1, 1, 0], [-1, -1, 0], [1, 0, 1], [1, 0, -1], [-1, 0, 1], [-1, 0, -1], [0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1]];

transform_vectors = [];

for (j = 0, len = transform_vectors_array.length; j < len; j++) {
  transform_vector_array = transform_vectors_array[j];
  transform_vectors.push(new THREE.Vector3(transform_vector_array[0], transform_vector_array[1], transform_vector_array[2]));
}

transform_matrices = [];

for (k = 0, len1 = transform_vectors.length; k < len1; k++) {
  transform_vector = transform_vectors[k];
  transform_matrices.push(new THREE.Matrix4().setPosition(transform_vector));
}

make_fractal = function(transform_matrices, base_geometry) {
  var current_geometry, geometries, geometry, l, len2, len3, m, result_geometry, transform_matrix;
  geometries = [];
  for (l = 0, len2 = transform_matrices.length; l < len2; l++) {
    transform_matrix = transform_matrices[l];
    current_geometry = base_geometry.clone();
    current_geometry.applyMatrix(transform_matrix);
    geometries.push(current_geometry);
  }
  result_geometry = new THREE.Geometry();
  for (m = 0, len3 = geometries.length; m < len3; m++) {
    geometry = geometries[m];
    result_geometry.merge(geometry);
  }
  result_geometry.scale(1 / 3, 1 / 3, 1 / 3);
  return result_geometry;
};

iter_geometry = base_geometry.clone();

for (i = l = 1, ref = ITER; 1 <= ref ? l <= ref : l >= ref; i = 1 <= ref ? ++l : --l) {
  iter_geometry = make_fractal(transform_matrices, iter_geometry);
}

cube = new THREE.Mesh(iter_geometry, material);

scene.add(cube);

//# sourceMappingURL=fractal.js.map
